//---------------------------------------------------------------------------


#pragma hdrstop

#include "AudioStreamer.h"
#include "bass.hpp"


//---------------------------------------------------------------------------
#pragma package(smart_init)

AudioStreamer::AudioStreamer()
{

}
//---------------------------------------------------------------------------

AudioStreamer::~AudioStreamer()
{

}
//---------------------------------------------------------------------------

bool AudioStreamer::connectDataChannel()
{
	if(_data_channel.doConnect(_host, _port) == -1) {
		return(false) ;
	} else {
		return(true) ;
    }

}
//---------------------------------------------------------------------------

bool AudioStreamer::connectDataChannel(string host, unsigned int port)
{
	_host = host ;
	_port = port ;

	return(connectDataChannel()) ;
}
//---------------------------------------------------------------------------

bool AudioStreamer::connectControlChannel()
{
	if(_control_channel.doConnect(_host, _port) == -1) {
		return(false) ;
	} else {
        return(true) ;
    }
}
//---------------------------------------------------------------------------

bool AudioStreamer::connectControlChannel(string host, unsigned int port)
{
	_host = host ;
	_port = port ;

	return(connectControlChannel()) ;
}
//---------------------------------------------------------------------------

bool AudioStreamer::startStreaming()
{
	return(false) ;
}
//---------------------------------------------------------------------------

bool AudioStreamer::stopStreaming()
{
	return(false) ;
}
//---------------------------------------------------------------------------

void AudioStreamer::setHost(string value)
{
	_host = value ;
}
//---------------------------------------------------------------------------

string AudioStreamer::getHost()
{
	return(_host) ;
}
//---------------------------------------------------------------------------

void AudioStreamer::setPort(unsigned int value)
{
	_port = value ;
}
//---------------------------------------------------------------------------

unsigned int AudioStreamer::getPort()
{
	return(_port) ;
}
//---------------------------------------------------------------------------

void AudioStreamer::setUsername(string value)
{
	_username = value ;
}
//---------------------------------------------------------------------------

string AudioStreamer::getUsername()
{
	return(_username) ;
}
//---------------------------------------------------------------------------

void AudioStreamer::setPassword(string value)
{
	_password = value ;
}
//---------------------------------------------------------------------------

string AudioStreamer::getPassword()
{
	return(_password) ;
}
//---------------------------------------------------------------------------

bool AudioStreamer::isConnected()
{
	return(_connected) ;
}
//---------------------------------------------------------------------------

void AudioStreamer::setAudioFormat(int value)
{
	_audio_format = value ;

	switch(_audio_format) {
		case OGG:
			_content_type = "audio/ogg" ;
			break ;
		case AAC:
			_content_type = "audio/aac" ;
			break ;
		case AACP:
			_content_type = "audio/aacp" ;
			break ;
		case FLAC:
			_content_type = "audio/ogg" ;
			break ;
		case MPEG:
			_content_type = "audio/mpeg" ;
			break ;
		default:
			_content_type = "audio/mpeg" ;
			break ;
    } ;
}
//---------------------------------------------------------------------------

int AudioStreamer::getAudioFormat()
{
	return(_audio_format) ;
}
//---------------------------------------------------------------------------

string AudioStreamer::getContentType()
{
	return(_content_type) ;
}
//---------------------------------------------------------------------------

int AudioStreamer::sendToDataChannel(char *data, int length, int type)
{
	int ret = 0;

	switch(type) {
		case HEADER_TYPE:
			ret = send(_data_channel.getSocket(), data, length, 0);
			break;

		case CODEC_TYPE:
			ret = send(_data_channel.getSocket(), data, length, 0);
			break;
	}

	return ret;
}
//---------------------------------------------------------------------------

int AudioStreamer::closeDataChannel()
{
	return(_data_channel.doClose()) ;
}
//---------------------------------------------------------------------------

int AudioStreamer::sendToControlChannel(char *data, int length, int type)
{
	int ret = 0;

	switch(type) {
		case HEADER_TYPE:
			ret = send(_control_channel.getSocket(), data, length, 0);
			break;

		case CODEC_TYPE:
			ret = send(_control_channel.getSocket(), data, length, 0);
			break;
	}

	return ret;
}
//---------------------------------------------------------------------------

int AudioStreamer::closeControlChannel()
{
	return(_control_channel.doClose()) ;
}
//---------------------------------------------------------------------------

int AudioStreamer::receiveFromDataChannel(char *data, int length)
{
	return(_data_channel.receive(data, length, 0)) ;
}
//---------------------------------------------------------------------------

int AudioStreamer::receiveFromControlChannel(char *data, int length)
{
	return(_control_channel.receive(data, length, 0)) ;
}
//---------------------------------------------------------------------------

void AudioStreamer::stopRecording() {
	BASS_ChannelStop(inRecHandle);
	m_BASSOpen = 0;
	BASS_RecordFree();
	gLiveRecording = false;
}
//---------------------------------------------------------------------------

int AudioStreamer::startRecording(int m_CurrentInputCard) {
	char	buffer[1024] = "";
	char	buf[255] = "";

	int		ret = BASS_RecordInit(m_CurrentInputCard);
	m_BASSOpen = 1;

	if(!ret) {
		DWORD	errorCode = BASS_ErrorGetCode();
		switch(errorCode) {
			case BASS_ERROR_ALREADY:
				// pWindow->generalStatusCallback((char *) "Recording device already opened!");
				return 0;

			case BASS_ERROR_DEVICE:
				// pWindow->generalStatusCallback((char *) "Recording device invalid!");
				return 0;

			case BASS_ERROR_DRIVER:
				// pWindow->generalStatusCallback((char *) "Recording device driver unavailable!");
				return 0;

			default:
				// pWindow->generalStatusCallback((char *) "There was an error opening the preferred Digital Audio In device!");
				return 0;
		}
	}

	inRecHandle = BASS_RecordStart(44100, 2, 0, &BASSwaveInputProc, NULL);

	int		n = 0;
	char	*name;
	for(n = 0; name = (char *)BASS_RecordGetInputName(n); n++) {
		float vol = 0.0;
		int s = BASS_RecordGetInput(n, &vol);
		if(!(s & BASS_INPUT_OFF)) {
			char	msg[255] = "";
			sprintf(msg, "Recording from %s", name);
			// pWindow->generalStatusCallback((void *) msg);
		}
	}

	gLiveRecording = true;

	return 1;
}
//---------------------------------------------------------------------------

BOOL CALLBACK AudioStreamer::BASSwaveInputProc(HRECORD handle, const void *buffer, DWORD length, void *user) {
	int			n;
	char		*name;
	static char currentDevice[1024] = "";

	if(gLiveRecording) {
		for(n = 0; name = (char *)BASS_RecordGetInputName(n); n++) {
			float currentVolume;

			int s = BASS_RecordGetInput(n, &currentVolume);
			if(!(s & BASS_INPUT_OFF)) {
				if(strcmp(currentDevice, name)) {
					strcpy(currentDevice, name);

					char	msg[255] = "";
					sprintf(msg, "Recording from %s", currentDevice);
					pWindow->generalStatusCallback((void *) msg);
				}

				/*
				 * setCurrentRecordingName(currentDevice);
				 */
			}
		}

		unsigned int	c_size = length;	/* in bytes. */
		short			*z = (short *) buffer;	/* signed short for pcm data. */

		int				numsamples = c_size / sizeof(short);

		int				nch = 2;
		int				srate = 44100;
		float			*samples;

		/*
		 * float samples[8196*16];
		 */
		samples = (float *) malloc(sizeof(float) * numsamples * 2);
		memset(samples, '\000', sizeof(float) * numsamples * 2);

		long	avgLeft = 0;
		long	avgRight = 0;
		int		flip = 0;

		for(int i = 0; i < numsamples; i++) {
			signed int	sample;
			sample = z[i];
			samples[i] = sample / 32767.f;

			/* clipping */
			if(samples[i] > 1.0) {
				samples[i] = 1.0;
			}

			if(samples[i] < -1.0) {
				samples[i] = -1.0;
			}
		}

		handleAllOutput((float *) samples, numsamples / nch, nch, srate);

		/*
		 * int ret;
		 * for (int j=0;
		 * j<gMain.gNumEncoders;
		 * j++) { ret = handle_output(g[j], (float *)samples, numsamples/nch, nch, srate);
		 * }
		 */
		free(samples);
		return 1;
	}
	else {
		return 0;
	}

	return 0;
}
//---------------------------------------------------------------------------



